# di-brain RAG 多路检索详解

本文档详细分析 di-brain 项目中 RAG 多路检索的具体流程、各检索引擎的作用及其检索出的数据。

---

## 目录

1. [多路检索架构概览](#1-多路检索架构概览)
2. [Milvus 向量检索（表元数据向量）](#2-milvus-向量检索表元数据向量)
3. [Elasticsearch BM25 检索（表描述文本）](#3-elasticsearch-bm25-检索表描述文本)
4. [Milvus+列信息检索](#4-milvus列信息检索)
5. [多路检索结果融合](#5-多路检索结果融合)
6. [Rerank 精排策略](#6-rerank-精排策略)
7. [完整检索流程代码解析](#7-完整检索流程代码解析)

---

## 1. 多路检索架构概览

### 1.1 为什么需要多路检索？

单一检索引擎各有局限：

- **向量检索**：擅长语义理解，但对精确关键词匹配较弱
- **全文检索**：擅长关键词匹配，但缺乏语义理解能力
- **列信息检索**：能找到包含特定字段的表，补充表级检索的盲区

多路检索通过**互补融合**，显著提升召回率和准确率。

### 1.2 多路检索架构图

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                           用户问题 (question)                                  │
└───────────────────────────────────┬──────────────────────────────────────────┘
                                    │
                    ┌───────────────┼───────────────┐
                    │               │               │
                    ▼               ▼               ▼
        ┌───────────────┐  ┌───────────────┐  ┌───────────────────┐
        │   Milvus      │  │ Elasticsearch │  │   Milvus          │
        │  表向量检索    │  │  BM25 检索    │  │  表+列向量检索     │
        │               │  │               │  │                   │
        │ Collection:   │  │ Index:        │  │ Collection:       │
        │ di_rag_hive_  │  │ di-rag-hive-  │  │ di_rag_hive_table │
        │ table_with_   │  │ description   │  │ _with_columns_    │
        │ ai_desc_v2    │  │               │  │ and_ai_desc_v2    │
        └───────┬───────┘  └───────┬───────┘  └─────────┬─────────┘
                │                  │                    │
                │   milvus_docs    │    es_docs         │  milvus_column_
                │                  │                    │  retrieve_docs
                └──────────────────┼────────────────────┘
                                   │
                                   ▼
                    ┌──────────────────────────┐
                    │  reciprocal_rank_fusion  │
                    │      (RRF 融合排序)       │
                    └────────────┬─────────────┘
                                 │
                                 ▼
                    ┌──────────────────────────┐
                    │   Rerank (多规则精排)     │
                    │  - query_count_30d       │
                    │  - market_region         │
                    │  - status                │
                    │  - data_marts            │
                    │  - visibility            │
                    │  - schema 匹配           │
                    │  - 用户历史查询          │
                    │  - team_region           │
                    └────────────┬─────────────┘
                                 │
                                 ▼
                    ┌──────────────────────────┐
                    │  Top-10 相关表           │
                    │  (ranked_docs)           │
                    └────────────┬─────────────┘
                                 │
                                 ▼
                    ┌──────────────────────────┐
                    │  列级检索 & 合并          │
                    │  (hive_column_retrieve)  │
                    │                          │
                    │  Collection:             │
                    │  di_rag_hive_column_     │
                    │  info_v2                 │
                    └────────────┬─────────────┘
                                 │
                                 ▼
                    ┌──────────────────────────┐
                    │  最终输出：表 + 列详情    │
                    └──────────────────────────┘
```

### 1.3 核心代码入口

**文件位置**：`di_brain/hive_query.py`

```python
# di_brain/hive_query.py (第 654-687 行)
def create_hive_table_retriever_chain(
    milvus_table_retriever: BaseRetriever,
    es_table_retriever: BaseRetriever,
    milvus_table_with_column_retriever: BaseRetriever,
) -> Runnable:
    table_retrieval_branch = RunnableBranch(
        # 如果用户指定了表，直接查询指定表
        (
            RunnableLambda(
                lambda x: bool(x.get("table_context"))
                and bool(x.get("table_context").get("hive_tables"))
            ),
            create_user_defined_table_docs_chain(),
        ),
        # 否则，执行多路并行检索
        (
            RunnableLambda(itemgetter("question")).with_config(
                run_name="Itemgetter:question"
            )
            | RunnableParallel(
                # ★ 路径1：Milvus 表向量检索
                milvus_docs=milvus_table_retriever.with_config(
                    run_name="retrieve tables from milvus"
                ),
                # ★ 路径2：ES BM25 检索
                es_docs=es_table_retriever.with_config(
                    run_name="retrieve tables from ElasticSearch"
                ),
                # ★ 路径3：Milvus 表+列信息检索
                milvus_column_retrieve_docs=milvus_table_with_column_retriever.with_config(
                    run_name="retrive table by column info from milvus"
                ),
            )
            # ★ 三路结果融合
            | RunnableLambda(choice_retrival_docs_by_score).with_config(
                run_name="choice retrival docs between es result and milvus result"
            )
        ),
    ).with_config(run_name="using user-defined-tables or retrieve from milvus")
    return table_retrieval_branch
```

---

## 2. Milvus 向量检索（表元数据向量）

### 2.1 作用

基于**语义相似度**检索与用户问题最相关的 Hive 表。

**核心能力**：

- 理解用户意图的语义，而非简单的关键词匹配
- "购买记录" 能匹配到 "order_fact"（订单事实表）
- 跨语言匹配：中文问题能匹配英文表描述

### 2.2 数据源

**Collection 名称**：`di_rag_hive_table_with_ai_desc_v2`

```python
# di_brain/hive_query.py (第 135-158 行)
def get_table_retriever() -> MilvusWithSimilarityRetriever:
    vs = MilvusWithQuery(
        connection_args=milvus_config,
        collection_name=os.environ.get(
            "MILVUS_COLLECTION_NAME", "di_rag_hive_table_with_ai_desc_v2"
        ),
        embedding_function=get_embeddings_model(),
        vector_field="table_vector",      # 向量字段
        primary_field="uid",              # 主键
    )
    return MilvusWithSimilarityRetriever(
        vectorstore=vs,
        search_kwargs={
            "k": RETRIEVE_LIMIT,          # 100 条
            "param": {
                "metric_type": "L2",      # L2 距离（欧氏距离）
                "params": {"nprobe": 1200, "reorder_k": 200},
            },
            "score_threshold": 600,       # 距离阈值
        },
    )
```

### 2.3 检索出的数据

| 字段              | 类型   | 说明                                             |
| ----------------- | ------ | ------------------------------------------------ |
| `uid`             | string | 表唯一标识，格式：`idc_region.schema.table_name` |
| `schema`          | string | 数据库名（如 `dwd`, `dim`, `ods`）               |
| `table_name`      | string | 表名                                             |
| `idc_region`      | string | 数据中心区域（`SG`, `USEast`）                   |
| `market_region`   | string | 市场区域（`SG`, `ID`, `TH` 等）                  |
| `team_region`     | string | 团队所在区域                                     |
| `query_count_7d`  | int    | 近 7 天查询次数                                  |
| `query_count_30d` | int    | 近 30 天查询次数                                 |
| `status`          | string | 表状态（`active`, `deprecated`）                 |
| `visibility`      | bool   | 是否可见                                         |
| `data_marts`      | string | 所属数据集市                                     |
| `ai_desc`         | string | AI 生成的表描述                                  |
| `page_content`    | string | 表的完整描述文本                                 |

**示例数据**：

```json
{
  "uid": "SG.dwd.dwd_order_fact_di",
  "schema": "dwd",
  "table_name": "dwd_order_fact_di",
  "idc_region": "SG",
  "market_region": "REG",
  "query_count_30d": 15234,
  "status": "active",
  "visibility": true,
  "data_marts": "Order Mart",
  "ai_desc": "This table stores daily incremental order transaction data...",
  "page_content": "hive table name: dwd.dwd_order_fact_di\ndescriptions:\nThis table contains order facts..."
}
```

### 2.4 检索过程

```
用户问题："哪个表有用户的订单信息？"
    │
    ▼
Embedding 模型转换为 384 维向量
    │
    ▼
Milvus 向量检索（L2 距离）
    │
    ▼
返回 Top-100 最相似的表
```

---

## 3. Elasticsearch BM25 检索（表描述文本）

### 3.1 作用

基于 **BM25 算法** 进行关键词匹配检索。

**核心能力**：

- 精确匹配用户提到的表名、字段名、业务术语
- 对包含精确关键词的文档给予高分
- 补充向量检索在精确匹配上的不足

### 3.2 数据源

**ES Index 名称**：`di-rag-hive-description`

```python
# di_brain/hive_query.py (第 93-105 行)
def get_es_table_retriever() -> BaseRetriever:
    bm25_retriever = ElasticsearchAdvanceRetriever.from_es_params(
        index_name="di-rag-hive-description",
        body_func=bm25_query,
        url=os.environ.get(
            "ES_HOST", "http://portal-regdi-es-717-general-test.data-infra.shopee.io:80"
        ),
        username="elastic",
        password="KgpcZdQkIhMI",
        document_mapper=es_hint_to_doc_mapper,
    )
    return bm25_retriever
```

### 3.3 BM25 查询构建

```python
# di_brain/hive_query.py (第 50-85 行)
def bm25_query(search_query: str, metadata: Dict) -> Dict:
    search_body = {
        "query": {
            "bool": {
                "must": {
                    "match": {
                        "text": {
                            "query": search_query,
                            "fuzziness": "0"  # 不使用模糊匹配
                        }
                    }
                }
            }
        },
        "size": RETRIEVE_LIMIT,  # 100 条
    }

    # 支持按 data_marts / table_schemas 过滤
    filter_condition = metadata.get("retrieve_filters")
    if filter_condition:
        mart_cond = filter_condition.get("data_marts")
        schema_cond = filter_condition.get("table_schemas")
        
        if mart_cond:
            mart_cond_dict = gen_should_condition("data_marts", mart_cond)
        if schema_cond:
            schema_cond_dict = gen_should_condition("schema", schema_cond)
        
        # 添加过滤条件
        if final_cond_dict:
            search_body["query"]["bool"]["filter"] = final_cond_dict

    return search_body
```

### 3.4 检索出的数据

```python
# di_brain/hive_query.py (第 38-47 行)
def es_hint_to_doc_mapper(hit: Mapping[str, Any]) -> Document:
    content = hit["_source"].pop("text")          # ★ 表描述文本
    other_properties = hit["_source"]             # 其它元数据
    other_properties["_score"] = hit["_score"]    # ★ BM25 相关性分数
    other_properties["uid"] = "%s.%s.%s" % (
        other_properties["idc_region"],
        other_properties["schema"],
        other_properties["table_name"],
    )
    return Document(page_content=content, metadata=other_properties)
```

| 字段           | 类型   | 说明                                 |
| -------------- | ------ | ------------------------------------ |
| `page_content` | string | 表描述文本（来自 ES 的 `text` 字段） |
| `_score`       | float  | BM25 相关性分数（越高越相关）        |
| `uid`          | string | 表唯一标识                           |
| `idc_region`   | string | 数据中心区域                         |
| `schema`       | string | 数据库名                             |
| `table_name`   | string | 表名                                 |
| `data_marts`   | string | 所属数据集市（用于过滤）             |

**示例数据**：

```json
{
  "page_content": "dwd_order_fact_di is a daily incremental order fact table that stores all order transactions...",
  "_score": 15.234,
  "uid": "SG.dwd.dwd_order_fact_di",
  "idc_region": "SG",
  "schema": "dwd",
  "table_name": "dwd_order_fact_di",
  "data_marts": "Order Mart"
}
```

### 3.5 检索过程

```
用户问题："dwd_order_fact 表有哪些字段？"
    │
    ▼
ES BM25 查询（精确匹配 "dwd_order_fact"）
    │
    ▼
返回 Top-100 匹配结果（按 _score 排序）
```

### 3.6 ES 与 Milvus 的互补

| 场景               | ES BM25        | Milvus 向量    |
| ------------------ | -------------- | -------------- |
| 用户提到具体表名   | ✅ 精确匹配     | ⚠️ 可能排名靠后 |
| 用户用同义词描述   | ❌ 无法匹配     | ✅ 语义理解     |
| 中英文混合查询     | ❌ 需要完全匹配 | ✅ 跨语言语义   |
| 包含特定关键词的表 | ✅ 精确召回     | ⚠️ 可能遗漏     |

---

## 4. Milvus+列信息检索

### 4.1 作用

基于**表的列信息**进行语义检索，找到包含特定字段的表。

**核心能力**：

- 当用户提到具体字段名时，能找到包含该字段的表
- 补充表级检索的盲区（表描述中可能没有提到所有字段）
- 支持按字段含义检索

### 4.2 数据源

#### 4.2.1 表+列综合向量库

**Collection 名称**：`di_rag_hive_table_with_columns_and_ai_desc_v2`

```python
# di_brain/hive_query.py (第 108-132 行)
def get_table_with_column_retriever() -> BaseRetriever:
    vs = MilvusWithQuery(
        connection_args=milvus_config,
        collection_name=os.environ.get(
            "MILVUS_TABLE_SCHEMA_COLLECTION_NAME",
            "di_rag_hive_table_with_columns_and_ai_desc_v2",
        ),
        embedding_function=get_embeddings_model(),
        vector_field="table_vector",
        primary_field="uid",
    )
    return MilvusWithSimilarityRetriever(
        vectorstore=vs,
        search_kwargs={
            "k": RETRIEVE_LIMIT,          # 100 条
            "param": {
                "metric_type": "L2",
                "params": {"nprobe": 1200, "reorder_k": 200},
            },
            "score_threshold": 600,
        },
    )
```

#### 4.2.2 列级向量库

**Collection 名称**：`di_rag_hive_column_info_v2`

```python
# di_brain/hive_query.py (第 161-183 行)
def get_hive_column_retriever(filter: str) -> MilvusWithSimilarityRetriever:
    vs = MilvusWithQuery(
        connection_args=milvus_config,
        collection_name=os.environ.get(
            "MILVUS_COLUMN_COLLECTION_NAME", "di_rag_hive_column_info_v2"
        ),
        embedding_function=get_embeddings_model(),
        vector_field="column_vector",     # ★ 列向量字段
        primary_field="id",
    )
    return MilvusWithSimilarityRetriever(
        vectorstore=vs,
        search_kwargs={
            "k": 200,
            "expr": filter,               # ★ 按 table_uid 过滤
            "param": {
                "metric_type": "L2",
                "params": {"nprobe": 1200, "reorder_k": 200},
            },
        },
    )
```

### 4.3 检索出的数据

#### 表+列综合检索结果

| 字段           | 类型   | 说明                    |
| -------------- | ------ | ----------------------- |
| `uid`          | string | 表唯一标识              |
| `schema`       | string | 数据库名                |
| `table_name`   | string | 表名                    |
| `page_content` | string | 表描述 + 列信息综合文本 |

#### 列级检索结果

| 字段                  | 类型   | 说明               |
| --------------------- | ------ | ------------------ |
| `id`                  | string | 列唯一标识         |
| `table_uid`           | string | 所属表的 uid       |
| `column_name`         | string | 列名               |
| `partition`           | bool   | 是否分区列         |
| `data_type`           | string | 数据类型           |
| `page_content`        | string | 列描述文本         |
| `datamap_description` | string | Datamap 中的列描述 |

**示例数据**：

```json
{
  "id": "SG.dwd.dwd_order_fact_di.order_id",
  "table_uid": "SG.dwd.dwd_order_fact_di",
  "column_name": "order_id",
  "partition": false,
  "data_type": "bigint",
  "page_content": "Column name: order_id\nIts description is:\nUnique identifier for each order...",
  "datamap_description": "Unique identifier for each order"
}
```

### 4.4 列检索与表合并

```python
# di_brain/hive_query.py (第 213-230 行)
def hive_column_retrieve_and_merge(_dict, config) -> List[Document]:
    input_docs = _dict["ranked_docs"]     # 经过 rerank 的表列表
    table_list = _dict["tables"]          # 表 uid 列表
    question = _dict["question"]
    
    # 1. 构造过滤表达式：只在已选中的表中检索列
    expr = "table_uid in [%s]" % ("'" + "','".join(table_list) + "'")
    
    # 2. 创建带过滤的列检索器
    retriever_with_filter = get_hive_column_retriever(expr)
    
    # 3. 检索与问题相关的列
    column_response = retriever_with_filter.invoke(question, config)

    # 4. 补充分区列（分区列必须返回，即使语义不相关）
    expr = expr + " and partition == True"
    partitions_columns = retriever_with_filter.query(expr)
    column_response = merge_column_docs(column_response, partitions_columns)

    # 5. 将列信息合并到表文档中
    return merge_hive_table_and_column_metadata(input_docs, column_response)
```

### 4.5 表+列合并逻辑

```python
# di_brain/hive_query.py (第 292-337 行)
def merge_hive_table_and_column_metadata(
    table_docs: List[Document], column_docs: List[Document]
) -> List[Document]:
    # 1. 按 table_uid 分组列信息
    table_column_dict = {}
    for item in column_docs:
        tb_id = item.metadata["table_uid"]
        item.metadata["datamap_description"] = extract_datamap_column_desc(
            item.page_content
        )
        tb_doc_list = table_column_dict.get(tb_id)
        if tb_doc_list is None:
            tb_doc_list = []
            table_column_dict[tb_id] = tb_doc_list
        tb_doc_list.append(item)

    # 2. 将列信息附加到对应的表文档
    for i, item in enumerate(table_docs):
        tb_id = item.metadata.pop("uid")
        item.metadata["source"] = data_map_url % (
            item.metadata["idc_region"],
            item.metadata["schema"],
            item.metadata["table_name"],
        )
        item.metadata["title"] = tb_id

        column_list = table_column_dict.get(tb_id)
        if column_list:
            # ★ 每个表最多保留 22 个列信息
            if len(column_list) > TABLE_COLUMN_ORIGIN_RETRIVE_LIMIT:
                column_list = column_list[:TABLE_COLUMN_ORIGIN_RETRIVE_LIMIT]
            item.metadata["columns"] = column_list  # ★ 列信息附加到表
    
    return table_docs
```

---

## 5. 多路检索结果融合

### 5.1 RRF (Reciprocal Rank Fusion) 算法

三路检索结果通过 **RRF 算法** 融合，公式：

```
RRF_score(d) = Σ 1 / (k + rank_i(d))

其中：
- d 是某个文档（表）
- k 是常数（默认 60）
- rank_i(d) 是文档 d 在第 i 路检索结果中的排名
```

### 5.2 融合代码

```python
# di_brain/hive_query.py (第 618-638 行)
def reciprocal_rank_fusion(results: list[list], k=60) -> List[Document]:
    fused_scores = {}
    docs_dict = {}
    
    for docs in results:
        for rank, doc in enumerate(docs):
            doc_str = doc.metadata["uid"]
            if doc_str not in fused_scores:
                fused_scores[doc_str] = 0
                docs_dict[doc_str] = doc
            previous_score = fused_scores[doc_str]
            # ★ RRF 公式：1 / (k + rank)
            fused_scores[doc_str] = previous_score + 1 / (rank + k)

    # 按融合分数降序排列
    reranked_results = [
        docs_dict[doc]
        for doc, score in sorted(fused_scores.items(), key=lambda x: x[1], reverse=True)
    ]
    
    # 将融合分数存入 metadata
    for doc_item in reranked_results:
        doc_item.metadata["fusion_score"] = fused_scores[doc_item.metadata["uid"]]

    return reranked_results
```

### 5.3 融合调用

```python
# di_brain/hive_query.py (第 588-607 行)
def choice_retrival_docs_by_score(_dict, config) -> List[Document]:
    es_result = _dict["es_docs"]
    milvus_result = _dict["milvus_docs"]
    milvus_column_retrieve_docs = _dict["milvus_column_retrieve_docs"]
    
    # 预处理列检索结果
    for doc_item in milvus_column_retrieve_docs:
        doc_item.page_content = "hive table name: %s.%s\n" % (
            doc_item.metadata["schema"],
            doc_item.metadata["table_name"],
        )
    
    # ★ 三路结果融合
    milvus_retrieve_list = [milvus_result, milvus_column_retrieve_docs, es_result]
    fusion_rag_list = reciprocal_rank_fusion(milvus_retrieve_list)
    
    # 取前 100 条
    final_list = fusion_rag_list[0:RETRIEVE_LIMIT]
    post_reciprocal_fusion_process(final_list)
    
    return final_list
```

### 5.4 融合示例

```
假设用户问题："订单表有哪些字段？"

Milvus 表向量检索结果：
  1. SG.dwd.dwd_order_fact_di     (rank=0)
  2. SG.dim.dim_order_dim         (rank=1)
  3. SG.ods.ods_order_raw         (rank=2)

ES BM25 检索结果：
  1. SG.ods.ods_order_raw         (rank=0)  ← 包含 "订单" 关键词
  2. SG.dwd.dwd_order_fact_di     (rank=1)
  3. SG.dim.dim_user_dim          (rank=2)

Milvus 列检索结果：
  1. SG.dwd.dwd_order_fact_di     (rank=0)  ← 包含 order_id 字段
  2. SG.dim.dim_order_dim         (rank=1)
  3. SG.ods.ods_order_raw         (rank=2)

RRF 融合计算（k=60）：
  SG.dwd.dwd_order_fact_di: 1/(60+0) + 1/(60+1) + 1/(60+0) = 0.0167 + 0.0164 + 0.0167 = 0.0498
  SG.ods.ods_order_raw:     1/(60+2) + 1/(60+0) + 1/(60+2) = 0.0161 + 0.0167 + 0.0161 = 0.0489
  SG.dim.dim_order_dim:     1/(60+1) + 1/(60+2) + 1/(60+1) = 0.0164 + 0.0161 + 0.0164 = 0.0489

最终排序：
  1. SG.dwd.dwd_order_fact_di  (0.0498)  ← 三路都排名靠前，最终第一
  2. SG.ods.ods_order_raw      (0.0489)
  3. SG.dim.dim_order_dim      (0.0489)
```

---

## 6. Rerank 精排策略

### 6.1 精排规则

RRF 融合后，还会经过 **8 条精排规则**：

```python
# di_brain/hive_query.py (第 413-491 行)
def generate_rerank_list(
    raw_list: List[Document], user_region: str, schema_set: set, user_email: str
) -> tuple[List[Dict], List[int]]:
    rank_list = []
    fusion_k_list = []
    
    # 规则 0：原始排序
    rank_list.append(get_rank_dict(raw_list))
    fusion_k_list.append(60)

    # 规则 1：按 30 天查询次数排序（热门表优先）
    rerank_list_1 = sorted(
        raw_list, key=lambda a: a.metadata["query_count_30d"], reverse=True
    )
    rank_list.append(get_rank_dict(rerank_list_1))
    fusion_k_list.append(60)

    # 规则 2：market_region 与用户区域匹配
    rerank_list_2 = sorted(
        raw_list,
        key=functools.cmp_to_key(lambda a, b: compare_region(a, b, user_region)),
        reverse=True,
    )
    rank_list.append(get_rank_dict(rerank_list_2))
    fusion_k_list.append(60)

    # 规则 3：表状态为 active
    rerank_list_3 = sorted(
        raw_list, key=functools.cmp_to_key(compare_status), reverse=True
    )
    rank_list.append(get_rank_dict(rerank_list_3))
    fusion_k_list.append(60)

    # 规则 4：有 data_mart 的表优先
    rerank_list_4 = sorted(
        raw_list, key=functools.cmp_to_key(compare_data_mart), reverse=True
    )
    rank_list.append(get_rank_dict(rerank_list_4))
    fusion_k_list.append(60)

    # 规则 5：visibility=true 优先
    rerank_list_5 = sorted(
        raw_list, key=functools.cmp_to_key(compare_visibility), reverse=True
    )
    rank_list.append(get_rank_dict(rerank_list_5))
    fusion_k_list.append(60)

    # 规则 6：schema 在用户常用 schema 集合中
    if len(schema_set) > 0:
        rerank_list_6 = sorted(
            raw_list,
            key=functools.cmp_to_key(lambda a, b: compare_schemas(a, b, schema_set)),
            reverse=True,
        )
        rank_list.append(get_rank_dict(rerank_list_6))
        fusion_k_list.append(60)

    # 规则 7：用户近 7 天查询过的表
    table_uid_list = [item.metadata["uid"] for item in raw_list]
    table_score_dict = query_count_batch(table_uid_list, user_email)
    rank_list.append(table_score_dict)
    fusion_k_list.append(60)

    # 规则 8：team_region 与用户区域匹配
    rerank_list_8 = sorted(
        raw_list,
        key=functools.cmp_to_key(lambda a, b: compare_team_region(a, b, user_region)),
        reverse=True,
    )
    rank_list.append(get_rank_dict(rerank_list_8))
    fusion_k_list.append(60)

    return rank_list, fusion_k_list
```

### 6.2 精排规则说明

| 规则   | 维度              | 说明                      |
| ------ | ----------------- | ------------------------- |
| 规则 1 | `query_count_30d` | 热门表优先（30 天查询量） |
| 规则 2 | `market_region`   | 用户所在市场的表优先      |
| 规则 3 | `status`          | `active` 状态的表优先     |
| 规则 4 | `data_marts`      | 有明确数据集市的表优先    |
| 规则 5 | `visibility`      | 可见的表优先              |
| 规则 6 | `schema`          | 用户常用 schema 的表优先  |
| 规则 7 | 用户历史          | 用户近期查询过的表优先    |
| 规则 8 | `team_region`     | 团队区域匹配的表优先      |

### 6.3 最终精排融合

```python
# di_brain/hive_query.py (第 385-401 行)
def fusion_rerank_v2(
    rank_list: List[Dict], raw_list: List[Document], fusion_k_list: List[int]
) -> List[Document]:
    rank_score_dict = {}
    
    # 对每条规则的排名，使用 RRF 公式计算综合分数
    for idx, single_rank in enumerate(rank_list):
        for k, v in single_rank.items():
            current_score = rank_score_dict.get(k)
            if current_score is None:
                rank_score_dict[k] = 1.0 / (fusion_k_list[idx] + v)
            else:
                rank_score_dict[k] = current_score + 1.0 / (fusion_k_list[idx] + v)

    # 按综合分数排序
    final_rank_ls = sorted(
        raw_list, key=lambda a: rank_score_dict[a.metadata["uid"]], reverse=True
    )
    
    return final_rank_ls
```

---

## 7. 完整检索流程代码解析

### 7.1 完整检索链

```python
# di_brain/chain.py (第 310-358 行)
def create_hive_meta_retriever_chain(
    milvus_table_retriever: BaseRetriever,
    es_table_retriever: BaseRetriever,
    milvus_table_with_column_retriever: BaseRetriever,
) -> Runnable:
    # 1. 问题改写链（处理多轮对话）
    CONDENSE_QUESTION_PROMPT = PromptTemplate.from_template(REPHRASE_TEMPLATE)
    condense_question_chain = (
        CONDENSE_QUESTION_PROMPT | llm | StrOutputParser()
    ).with_config(run_name="CondenseQuestion")
    
    # 2. 多路检索链
    table_retrieval_branch_chain = create_hive_table_retriever_chain(
        milvus_table_retriever, es_table_retriever, milvus_table_with_column_retriever
    )

    # 3. 带历史对话的检索链
    conversation_chain = (
        RunnablePassthrough.assign(question=condense_question_chain)
        | table_retrieval_branch_chain
    )
    
    # 4. 路由：有历史对话走改写，无历史直接检索
    runnable_branch = RunnableBranch(
        (
            RunnableLambda(lambda x: bool(x.get("chat_history"))),
            conversation_chain.with_config(run_name="RetrievalChainWithHistory"),
        ),
        table_retrieval_branch_chain.with_config(run_name="RetrievalChainWithNoHistory"),
    )

    # 5. Rerank 精排链
    rerank_chain = {
        "table_docs": runnable_branch,
        "context": create_req_context_extract_chain(),
    } | create_rerank_chain()

    # 6. 检索 + 精排包装
    retrival_and_rerank = (
        RunnablePassthrough.assign(ranked_docs=rerank_chain)
        .assign(tables=lambda x: [y.metadata["uid"] for y in x["ranked_docs"]])
        .with_config(run_name="retrieve table meta and rerank wrapper")
    )

    # 7. 列信息检索 + 合并
    hive_column_retriever_and_append = (
        create_column_retrieve_and_merge_chain().with_config(run_name="FindDocs")
    )

    # 8. 完整链：检索 → 精排 → 列合并
    return retrival_and_rerank | hive_column_retriever_and_append
```

### 7.2 流程总结

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        完整检索流程                                       │
└─────────────────────────────────────────────────────────────────────────┘

1. 用户问题输入
       │
       ▼
2. [可选] 问题改写（多轮对话场景）
       │
       ▼
3. 多路并行检索
       │
       ├─→ Milvus 表向量检索 ──→ 100 条
       ├─→ ES BM25 检索 ──────→ 100 条  
       └─→ Milvus 列检索 ─────→ 100 条
       │
       ▼
4. RRF 融合排序
       │
       ▼
5. 取 Top-100 → 8 规则精排 → Top-10
       │
       ▼
6. 列级检索（在 Top-10 表中搜索相关列）
       │
       ├─→ 语义相关列
       └─→ 分区列（必返回）
       │
       ▼
7. 表 + 列信息合并
       │
       ▼
8. 最终输出：10 张表，每张表带 ≤22 个相关列
```

---

## 总结

| 检索路径          | 数据源                                          | 核心能力             | 检索数据          |
| ----------------- | ----------------------------------------------- | -------------------- | ----------------- |
| **Milvus 表向量** | `di_rag_hive_table_with_ai_desc_v2`             | 语义理解、跨语言匹配 | 表元数据 + 描述   |
| **ES BM25**       | `di-rag-hive-description`                       | 精确关键词匹配       | 表描述文本 + 分数 |
| **Milvus 表+列**  | `di_rag_hive_table_with_columns_and_ai_desc_v2` | 按列信息检索表       | 表+列综合向量     |
| **Milvus 列级**   | `di_rag_hive_column_info_v2`                    | 字段级语义检索       | 列元数据 + 描述   |

**三路检索互补优势**：

1. 向量检索擅长**语义理解**，弥补关键词检索的语义盲区
2. BM25 擅长**精确匹配**，保证用户提到的表名/字段名能被召回
3. 列检索补充**字段级召回**，当用户关注具体字段时更精准

**最终效果**：通过 RRF 融合 + 8 规则精排，确保返回的 Top-10 表既相关又符合用户偏好。